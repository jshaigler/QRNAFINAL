"""
Simplified RNA Folding Module for WebAssembly
This is a lightweight version that can run in Pyodide
"""

import json
from typing import Dict, List, Any, Tuple
import random


class SimplifiedRNAFolder:
    """Simplified RNA folding that works in WebAssembly environment"""

    def __init__(self):
        self.base_pairs = {'A': 'U', 'U': 'A', 'G': 'C', 'C': 'G'}

    def calculate_mfe(self, sequence: str) -> float:
        """
        Calculate minimum free energy using simplified Turner rules
        Returns energy in kcal/mol
        """
        # Simplified energy model
        gc_count = sequence.count('G') + sequence.count('C')
        au_count = sequence.count('A') + sequence.count('U')

        # Base pairing energy
        energy = -2.1 * gc_count - 1.1 * au_count

        # Add length penalty for stability
        energy += len(sequence) * 0.1

        return energy

    def predict_structure(self, sequence: str) -> Dict[str, Any]:
        """
        Predict secondary structure using simplified Nussinov algorithm
        Returns structure in dot-bracket notation
        """
        n = len(sequence)

        # Dynamic programming matrix
        dp = [[0 for _ in range(n)] for _ in range(n)]

        # Fill matrix
        for length in range(2, n + 1):
            for i in range(n - length + 1):
                j = i + length - 1

                # Try to pair i with j
                if self._can_pair(sequence[i], sequence[j]):
                    dp[i][j] = dp[i+1][j-1] + 1

                # Try other configurations
                for k in range(i, j):
                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j])

        # Traceback to get structure
        structure = self._traceback(dp, sequence, 0, n-1)

        return {
            'sequence': sequence,
            'structure': structure,
            'mfe': self.calculate_mfe(sequence),
            'base_pairs': dp[0][n-1] if n > 0 else 0
        }

    def _can_pair(self, base1: str, base2: str) -> bool:
        """Check if two bases can form a pair"""
        return self.base_pairs.get(base1) == base2

    def _traceback(self, dp: List[List[int]], seq: str, i: int, j: int) -> str:
        """Traceback to generate dot-bracket notation"""
        if i >= j:
            return '.' * max(0, j - i + 1)

        structure = ['.' for _ in range(j - i + 1)]
        self._traceback_helper(dp, seq, i, j, structure, i)

        return ''.join(structure)

    def _traceback_helper(self, dp: List[List[int]], seq: str,
                          i: int, j: int, structure: List[str], offset: int):
        """Helper for traceback"""
        if i >= j:
            return

        if self._can_pair(seq[i], seq[j]) and dp[i][j] == dp[i+1][j-1] + 1:
            structure[i - offset] = '('
            structure[j - offset] = ')'
            self._traceback_helper(dp, seq, i+1, j-1, structure, offset)
        else:
            for k in range(i, j):
                if dp[i][j] == dp[i][k] + dp[k+1][j]:
                    self._traceback_helper(dp, seq, i, k, structure, offset)
                    self._traceback_helper(dp, seq, k+1, j, structure, offset)
                    break


class SimplifiedQuantumSimulator:
    """Simplified quantum-inspired sampling for RNA structures"""

    def __init__(self):
        self.folder = SimplifiedRNAFolder()
        self.bases = ['A', 'U', 'G', 'C']

    def generate_candidates(self, length: int, num_candidates: int = 10) -> List[Dict[str, Any]]:
        """
        Generate RNA sequence candidates using quantum-inspired sampling
        """
        candidates = []

        for i in range(num_candidates):
            # Generate sequence with bias towards stable base composition
            sequence = self._generate_biased_sequence(length)

            # Predict structure
            result = self.folder.predict_structure(sequence)

            # Add metadata
            result['id'] = f'RNA_{i:05d}'
            result['generation_method'] = 'quantum_inspired'
            result['stability_score'] = self._calculate_stability(result)

            candidates.append(result)

        # Sort by stability
        candidates.sort(key=lambda x: x['stability_score'], reverse=True)

        return candidates

    def _generate_biased_sequence(self, length: int) -> str:
        """Generate sequence with GC content bias for stability"""
        sequence = []
        gc_bias = 0.55  # Prefer GC pairs for stability

        for _ in range(length):
            if random.random() < gc_bias:
                sequence.append(random.choice(['G', 'C']))
            else:
                sequence.append(random.choice(['A', 'U']))

        return ''.join(sequence)

    def _calculate_stability(self, structure_result: Dict[str, Any]) -> float:
        """Calculate stability score"""
        mfe = structure_result['mfe']
        base_pairs = structure_result['base_pairs']
        length = len(structure_result['sequence'])

        # Normalize by length
        if length > 0:
            stability = (base_pairs / length) * 100 - abs(mfe) / 10
        else:
            stability = 0

        return stability


class QuantumRNAPipeline:
    """
    Simplified quantum RNA pipeline for WebAssembly
    """

    def __init__(self, config: Dict[str, Any] = None):
        self.config = config or {}
        self.folder = SimplifiedRNAFolder()
        self.quantum_simulator = SimplifiedQuantumSimulator()

    def run_pipeline(self, target_name: str = "unknown",
                    disease: str = "unknown",
                    sequence_length: int = 50,
                    num_candidates: int = 20) -> Dict[str, Any]:
        """
        Run the simplified quantum RNA pipeline

        Args:
            target_name: Target protein name
            disease: Disease indication
            sequence_length: Length of RNA sequences to generate
            num_candidates: Number of candidates to generate

        Returns:
            Dictionary with results
        """

        # Generate candidates
        candidates = self.quantum_simulator.generate_candidates(
            sequence_length,
            num_candidates
        )

        # Select top leads (top 10)
        leads = candidates[:10]

        # Format results
        result = {
            'success': True,
            'target_name': target_name,
            'disease': disease,
            'num_leads': len(leads),
            'leads': [
                {
                    'id': lead['id'],
                    'sequence': lead['sequence'],
                    'structure': lead['structure'],
                    'mfe': lead['mfe'],
                    'stability_score': lead['stability_score'],
                    'base_pairs': lead['base_pairs'],
                    'generation_method': lead['generation_method']
                }
                for lead in leads
            ],
            'metrics': {
                'total_candidates': num_candidates,
                'sequence_length': sequence_length,
                'avg_stability': sum(l['stability_score'] for l in leads) / len(leads) if leads else 0,
                'avg_mfe': sum(l['mfe'] for l in leads) / len(leads) if leads else 0
            }
        }

        return result


# Main entry point for Pyodide
def run_quantum_rna_pipeline(target_name: str = "unknown",
                             disease: str = "unknown",
                             sequence_length: int = 50,
                             num_candidates: int = 20) -> str:
    """
    Main entry point that returns JSON string
    """
    pipeline = QuantumRNAPipeline()
    result = pipeline.run_pipeline(
        target_name=target_name,
        disease=disease,
        sequence_length=sequence_length,
        num_candidates=num_candidates
    )
    return json.dumps(result)


# For testing in Python environment
if __name__ == '__main__':
    result = run_quantum_rna_pipeline("TestTarget", "TestDisease", 30, 10)
    print(result)
