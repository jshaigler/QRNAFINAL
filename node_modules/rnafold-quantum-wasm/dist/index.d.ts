export interface RnaFoldQuantumJob {
    job_id: string;
    status: 'running' | 'completed' | 'error';
    progress: number;
    message: string;
    leads?: any[];
    metrics?: any;
}
export interface RnaFoldResult {
    success: boolean;
    target_name: string;
    disease: string;
    num_leads: number;
    leads: Array<{
        id: string;
        sequence: string;
        structure: string;
        mfe: number;
        stability_score: number;
        base_pairs: number;
        generation_method: string;
    }>;
    metrics: {
        total_candidates: number;
        sequence_length: number;
        avg_stability: number;
        avg_mfe: number;
    };
}
export interface RnaFoldOptions {
    targetName?: string;
    disease?: string;
    sequenceLength?: number;
    numCandidates?: number;
}
/**
 * Standalone RNA Fold Quantum Client with WebAssembly support
 *
 * This client runs all RNA folding calculations locally using WebAssembly (Pyodide)
 * and does not require a localhost server.
 */
export declare class RnaFoldQuantumClient {
    private useWasm;
    private baseUrl?;
    /**
     * Create a new RnaFoldQuantumClient
     *
     * @param options - Configuration options
     * @param options.useWasm - If true, use WebAssembly for local calculations (default: true)
     * @param options.baseUrl - If useWasm is false, use this server URL for remote calculations
     */
    constructor(options?: {
        useWasm?: boolean;
        baseUrl?: string;
    });
    /**
     * Initialize the client (loads Pyodide if using WASM)
     */
    initialize(): Promise<void>;
    /**
     * Run the RNA folding pipeline
     *
     * @param options - Pipeline options
     * @returns Promise with the folding results
     */
    runPipeline(options?: RnaFoldOptions): Promise<RnaFoldResult>;
    /**
     * Run pipeline using WebAssembly
     */
    private runPipelineWasm;
    /**
     * Predict structure for a single RNA sequence
     *
     * @param sequence - RNA sequence (A, U, G, C)
     * @returns Structure prediction with MFE
     */
    predictStructure(sequence: string): Promise<{
        sequence: string;
        structure: string;
        mfe: number;
        base_pairs: number;
    }>;
    /**
     * Generate RNA candidates using quantum-inspired sampling
     *
     * @param length - Length of RNA sequences
     * @param numCandidates - Number of candidates to generate
     * @returns Array of candidate structures
     */
    generateCandidates(length: number, numCandidates?: number): Promise<Array<{
        id: string;
        sequence: string;
        structure: string;
        mfe: number;
        stability_score: number;
    }>>;
    healthCheck(): Promise<any>;
    getJobStatus(jobId: string): Promise<RnaFoldQuantumJob>;
    getJobResults(jobId: string): Promise<any>;
    getVisualizations(jobId: string): Promise<any>;
    configureQuantum(apiToken: string): Promise<{
        success: boolean;
        message: string;
    }>;
}
export { getPyodideLoader } from './pyodide-loader';
