// rna-fold-quantum-client/src/index.ts

import { getPyodideLoader } from './pyodide-loader';

export interface RnaFoldQuantumJob {
    job_id: string;
    status: 'running' | 'completed' | 'error';
    progress: number;
    message: string;
    leads?: any[];
    metrics?: any;
}

export interface RnaFoldResult {
    success: boolean;
    target_name: string;
    disease: string;
    num_leads: number;
    leads: Array<{
        id: string;
        sequence: string;
        structure: string;
        mfe: number;
        stability_score: number;
        base_pairs: number;
        generation_method: string;
    }>;
    metrics: {
        total_candidates: number;
        sequence_length: number;
        avg_stability: number;
        avg_mfe: number;
    };
}

export interface RnaFoldOptions {
    targetName?: string;
    disease?: string;
    sequenceLength?: number;
    numCandidates?: number;
}

/**
 * Standalone RNA Fold Quantum Client with WebAssembly support
 *
 * This client runs all RNA folding calculations locally using WebAssembly (Pyodide)
 * and does not require a localhost server.
 */
export class RnaFoldQuantumClient {
    private useWasm: boolean;
    private baseUrl?: string;

    /**
     * Create a new RnaFoldQuantumClient
     *
     * @param options - Configuration options
     * @param options.useWasm - If true, use WebAssembly for local calculations (default: true)
     * @param options.baseUrl - If useWasm is false, use this server URL for remote calculations
     */
    constructor(options: { useWasm?: boolean; baseUrl?: string } = {}) {
        this.useWasm = options.useWasm !== false; // Default to true
        this.baseUrl = options.baseUrl;

        if (!this.useWasm && !this.baseUrl) {
            throw new Error('baseUrl is required when useWasm is false');
        }
    }

    /**
     * Initialize the client (loads Pyodide if using WASM)
     */
    async initialize(): Promise<void> {
        if (this.useWasm) {
            const loader = getPyodideLoader();
            await loader.initialize();
        }
    }

    /**
     * Run the RNA folding pipeline
     *
     * @param options - Pipeline options
     * @returns Promise with the folding results
     */
    async runPipeline(options: RnaFoldOptions = {}): Promise<RnaFoldResult> {
        if (this.useWasm) {
            return this.runPipelineWasm(options);
        } else {
            // Legacy: use remote server (backwards compatibility)
            throw new Error('Remote server mode not yet implemented in v2. Use useWasm: true');
        }
    }

    /**
     * Run pipeline using WebAssembly
     */
    private async runPipelineWasm(options: RnaFoldOptions): Promise<RnaFoldResult> {
        const {
            targetName = 'unknown',
            disease = 'unknown',
            sequenceLength = 50,
            numCandidates = 20
        } = options;

        try {
            const loader = getPyodideLoader();
            await loader.initialize();

            console.log('Running quantum RNA pipeline with WebAssembly...');

            // Call Python function
            const resultJson = await loader.runPython(`
import json
from rna_folding_simplified import run_quantum_rna_pipeline

result = run_quantum_rna_pipeline(
    target_name="${targetName}",
    disease="${disease}",
    sequence_length=${sequenceLength},
    num_candidates=${numCandidates}
)

result
            `);

            // Parse result
            const result = JSON.parse(resultJson);

            console.log(`Pipeline completed: ${result.num_leads} leads found`);

            return result;

        } catch (error) {
            console.error('Pipeline execution failed:', error);
            throw new Error(`Pipeline execution failed: ${error}`);
        }
    }

    /**
     * Predict structure for a single RNA sequence
     *
     * @param sequence - RNA sequence (A, U, G, C)
     * @returns Structure prediction with MFE
     */
    async predictStructure(sequence: string): Promise<{
        sequence: string;
        structure: string;
        mfe: number;
        base_pairs: number;
    }> {
        if (!this.useWasm) {
            throw new Error('predictStructure only available in WASM mode');
        }

        try {
            const loader = getPyodideLoader();
            await loader.initialize();

            const resultJson = await loader.runPython(`
import json
from rna_folding_simplified import SimplifiedRNAFolder

folder = SimplifiedRNAFolder()
result = folder.predict_structure("${sequence}")
json.dumps(result)
            `);

            return JSON.parse(resultJson);

        } catch (error) {
            console.error('Structure prediction failed:', error);
            throw new Error(`Structure prediction failed: ${error}`);
        }
    }

    /**
     * Generate RNA candidates using quantum-inspired sampling
     *
     * @param length - Length of RNA sequences
     * @param numCandidates - Number of candidates to generate
     * @returns Array of candidate structures
     */
    async generateCandidates(length: number, numCandidates: number = 10): Promise<Array<{
        id: string;
        sequence: string;
        structure: string;
        mfe: number;
        stability_score: number;
    }>> {
        if (!this.useWasm) {
            throw new Error('generateCandidates only available in WASM mode');
        }

        try {
            const loader = getPyodideLoader();
            await loader.initialize();

            const resultJson = await loader.runPython(`
import json
from rna_folding_simplified import SimplifiedQuantumSimulator

simulator = SimplifiedQuantumSimulator()
candidates = simulator.generate_candidates(${length}, ${numCandidates})
json.dumps(candidates)
            `);

            return JSON.parse(resultJson);

        } catch (error) {
            console.error('Candidate generation failed:', error);
            throw new Error(`Candidate generation failed: ${error}`);
        }
    }

    // ========== Legacy Remote Server Methods (for backwards compatibility) ==========

    async healthCheck(): Promise<any> {
        if (this.useWasm) {
            return { status: 'ok', mode: 'wasm' };
        }

        const response = await fetch(`${this.baseUrl}/api/health`);
        if (!response.ok) {
            throw new Error('Health check failed');
        }
        return response.json();
    }

    async getJobStatus(jobId: string): Promise<RnaFoldQuantumJob> {
        if (this.useWasm) {
            throw new Error('Job status not applicable in WASM mode');
        }

        const response = await fetch(`${this.baseUrl}/api/status/${jobId}`);
        if (!response.ok) {
            throw new Error(`Failed to get job status for ${jobId}`);
        }
        return response.json();
    }

    async getJobResults(jobId: string): Promise<any> {
        if (this.useWasm) {
            throw new Error('Job results not applicable in WASM mode');
        }

        const response = await fetch(`${this.baseUrl}/api/results/${jobId}`);
        if (!response.ok) {
            throw new Error(`Failed to get job results for ${jobId}`);
        }
        return response.json();
    }

    async getVisualizations(jobId: string): Promise<any> {
        if (this.useWasm) {
            throw new Error('Visualizations not yet implemented in WASM mode');
        }

        const response = await fetch(`${this.baseUrl}/api/visualizations/${jobId}`);
        if (!response.ok) {
            throw new Error(`Failed to get visualizations for ${jobId}`);
        }
        return response.json();
    }

    async configureQuantum(apiToken: string): Promise<{ success: boolean; message: string }> {
        if (this.useWasm) {
            return { success: true, message: 'Quantum configuration not needed in WASM mode' };
        }

        const response = await fetch(`${this.baseUrl}/api/configure-quantum`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ api_token: apiToken }),
        });
        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.error || 'Failed to configure quantum backend');
        }
        return response.json();
    }
}

// Export for convenience
export { getPyodideLoader } from './pyodide-loader';
