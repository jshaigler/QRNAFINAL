"use strict";
// rna-fold-quantum-client/src/index.ts
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPyodideLoader = exports.RnaFoldQuantumClient = void 0;
const pyodide_loader_1 = require("./pyodide-loader");
/**
 * Standalone RNA Fold Quantum Client with WebAssembly support
 *
 * This client runs all RNA folding calculations locally using WebAssembly (Pyodide)
 * and does not require a localhost server.
 */
class RnaFoldQuantumClient {
    /**
     * Create a new RnaFoldQuantumClient
     *
     * @param options - Configuration options
     * @param options.useWasm - If true, use WebAssembly for local calculations (default: true)
     * @param options.baseUrl - If useWasm is false, use this server URL for remote calculations
     */
    constructor(options = {}) {
        this.useWasm = options.useWasm !== false; // Default to true
        this.baseUrl = options.baseUrl;
        if (!this.useWasm && !this.baseUrl) {
            throw new Error('baseUrl is required when useWasm is false');
        }
    }
    /**
     * Initialize the client (loads Pyodide if using WASM)
     */
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.useWasm) {
                const loader = (0, pyodide_loader_1.getPyodideLoader)();
                yield loader.initialize();
            }
        });
    }
    /**
     * Run the RNA folding pipeline
     *
     * @param options - Pipeline options
     * @returns Promise with the folding results
     */
    runPipeline() {
        return __awaiter(this, arguments, void 0, function* (options = {}) {
            if (this.useWasm) {
                return this.runPipelineWasm(options);
            }
            else {
                // Legacy: use remote server (backwards compatibility)
                throw new Error('Remote server mode not yet implemented in v2. Use useWasm: true');
            }
        });
    }
    /**
     * Run pipeline using WebAssembly
     */
    runPipelineWasm(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const { targetName = 'unknown', disease = 'unknown', sequenceLength = 50, numCandidates = 20 } = options;
            try {
                const loader = (0, pyodide_loader_1.getPyodideLoader)();
                yield loader.initialize();
                console.log('Running quantum RNA pipeline with WebAssembly...');
                // Call Python function
                const resultJson = yield loader.runPython(`
import json
from rna_folding_simplified import run_quantum_rna_pipeline

result = run_quantum_rna_pipeline(
    target_name="${targetName}",
    disease="${disease}",
    sequence_length=${sequenceLength},
    num_candidates=${numCandidates}
)

result
            `);
                // Parse result
                const result = JSON.parse(resultJson);
                console.log(`Pipeline completed: ${result.num_leads} leads found`);
                return result;
            }
            catch (error) {
                console.error('Pipeline execution failed:', error);
                throw new Error(`Pipeline execution failed: ${error}`);
            }
        });
    }
    /**
     * Predict structure for a single RNA sequence
     *
     * @param sequence - RNA sequence (A, U, G, C)
     * @returns Structure prediction with MFE
     */
    predictStructure(sequence) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.useWasm) {
                throw new Error('predictStructure only available in WASM mode');
            }
            try {
                const loader = (0, pyodide_loader_1.getPyodideLoader)();
                yield loader.initialize();
                const resultJson = yield loader.runPython(`
import json
from rna_folding_simplified import SimplifiedRNAFolder

folder = SimplifiedRNAFolder()
result = folder.predict_structure("${sequence}")
json.dumps(result)
            `);
                return JSON.parse(resultJson);
            }
            catch (error) {
                console.error('Structure prediction failed:', error);
                throw new Error(`Structure prediction failed: ${error}`);
            }
        });
    }
    /**
     * Generate RNA candidates using quantum-inspired sampling
     *
     * @param length - Length of RNA sequences
     * @param numCandidates - Number of candidates to generate
     * @returns Array of candidate structures
     */
    generateCandidates(length_1) {
        return __awaiter(this, arguments, void 0, function* (length, numCandidates = 10) {
            if (!this.useWasm) {
                throw new Error('generateCandidates only available in WASM mode');
            }
            try {
                const loader = (0, pyodide_loader_1.getPyodideLoader)();
                yield loader.initialize();
                const resultJson = yield loader.runPython(`
import json
from rna_folding_simplified import SimplifiedQuantumSimulator

simulator = SimplifiedQuantumSimulator()
candidates = simulator.generate_candidates(${length}, ${numCandidates})
json.dumps(candidates)
            `);
                return JSON.parse(resultJson);
            }
            catch (error) {
                console.error('Candidate generation failed:', error);
                throw new Error(`Candidate generation failed: ${error}`);
            }
        });
    }
    // ========== Legacy Remote Server Methods (for backwards compatibility) ==========
    healthCheck() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.useWasm) {
                return { status: 'ok', mode: 'wasm' };
            }
            const response = yield fetch(`${this.baseUrl}/api/health`);
            if (!response.ok) {
                throw new Error('Health check failed');
            }
            return response.json();
        });
    }
    getJobStatus(jobId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.useWasm) {
                throw new Error('Job status not applicable in WASM mode');
            }
            const response = yield fetch(`${this.baseUrl}/api/status/${jobId}`);
            if (!response.ok) {
                throw new Error(`Failed to get job status for ${jobId}`);
            }
            return response.json();
        });
    }
    getJobResults(jobId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.useWasm) {
                throw new Error('Job results not applicable in WASM mode');
            }
            const response = yield fetch(`${this.baseUrl}/api/results/${jobId}`);
            if (!response.ok) {
                throw new Error(`Failed to get job results for ${jobId}`);
            }
            return response.json();
        });
    }
    getVisualizations(jobId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.useWasm) {
                throw new Error('Visualizations not yet implemented in WASM mode');
            }
            const response = yield fetch(`${this.baseUrl}/api/visualizations/${jobId}`);
            if (!response.ok) {
                throw new Error(`Failed to get visualizations for ${jobId}`);
            }
            return response.json();
        });
    }
    configureQuantum(apiToken) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.useWasm) {
                return { success: true, message: 'Quantum configuration not needed in WASM mode' };
            }
            const response = yield fetch(`${this.baseUrl}/api/configure-quantum`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ api_token: apiToken }),
            });
            if (!response.ok) {
                const error = yield response.json();
                throw new Error(error.error || 'Failed to configure quantum backend');
            }
            return response.json();
        });
    }
}
exports.RnaFoldQuantumClient = RnaFoldQuantumClient;
// Export for convenience
var pyodide_loader_2 = require("./pyodide-loader");
Object.defineProperty(exports, "getPyodideLoader", { enumerable: true, get: function () { return pyodide_loader_2.getPyodideLoader; } });
